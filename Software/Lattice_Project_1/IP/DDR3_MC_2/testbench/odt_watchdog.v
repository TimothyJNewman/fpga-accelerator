// ===========================================================================
// Verilog module generated by IPexpress
// Filename: odt_watchdog.v  
// Copyright 2013 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

`timescale 1 ps / 1 ps
`include "ddr3_sdram_mem_params.vh"
module odt_watchdog(
    mem_clk,
    rst_n,
    //------- Signals from SDRAM side
    ddr_cke,                    // DDR3 SDRAM Clock enable
    ddr_cs_n,                   // DDR3 SDRAM Chip select
    ddr_we_n,                   // DDR3 SDRAM Write enable
    ddr_cas_n,                  // DDR3 SDRAM Column address strobe
    ddr_ras_n,                  // DDR3 SDRAM Row address strobe
    ddr_ad,                     // DDR3 SDRAM Address bus
    ddr_ba,                     // DDR3 SDRAM Bank bus
    ddr_dqm,                    // DDR3 SDRAM Data Mask signal
    ddr_dq,                     // DDR3 SDRAM Data Bus
    ddr_dqs,                    // DDR3 SDRAM Data Strobe
    ddr_odt,                    // DDR3 SDRAM ODT signal

    //------- Signals from Monitor
    burst_len,
    cas_latency,
    cas_write_latency,
    self_ref_done,
    odt_error_flg
);

`include "dut_params.v"

input                      mem_clk;
input                      rst_n;

input                      ddr_cke;
input  [CS_WIDTH-1:0]     ddr_cs_n;
input                      ddr_we_n;
input                      ddr_cas_n;
input                      ddr_ras_n;

localparam ROW_WDTH = (ROW_WIDTH == 12) ? (ROW_WIDTH+1):ROW_WIDTH;
input  [ROW_WDTH-1:0]    ddr_ad;

input  [2:0]   ddr_ba;
input  [DATA_WIDTH-1:0]   ddr_dq;
input  [DQS_WIDTH-1:0] ddr_dqm;
input  [DQS_WIDTH-1:0]    ddr_dqs;
input  [CS_WIDTH-1:0]     ddr_odt;
input  [1:0]               burst_len;
input  [3:0]               cas_latency;
input  [3:0]               cas_write_latency;
input                      self_ref_done;
output                     odt_error_flg;

///////////////////////////////////////////////////////////////////////
// delay the DQS signal so that the edge is sepearted from the clock.
wire   [DSIZE/16-1:0] ddr_dqs_dly;
assign #1 ddr_dqs_dly = ddr_dqs;
///////////////////////////////////////////////////////////////////////
wire                   mem_clk_dly;

///////////////////////////////////////////////////////////////////////
// flopped signals
reg                    mem_pd_cmd_d;
reg                    mem_sref_cmd_d;
reg                    mem_rd_cmd_d;
reg                    mem_wr_cmd_d;
reg                    mem_lmr_cmd_d;


// signals that indicate the type of command at the memory interface
wire                   mem_sref_cmd;
wire                   mem_sref_ext_cmd;
wire                   mem_pd_cmd;
wire                   mem_pd_ext_cmd;
wire                   mem_lmr_cmd;
wire                   mem_aref_cmd;
wire                   mem_act_cmd;
wire                   mem_pre_cmd;
wire                   mem_rd_cmd;
reg                    mem_rd_cmd_2d;
reg                    mem_rd_cmd_3d;
reg                    mem_rd_cmd_4d;
wire                   mem_wr_cmd;
wire                   mem_nop_cmd;

// power active 
wire                    pd_active;
wire                    sr_active;
reg                     pd_active_d;
reg                     sr_active_d;

reg                   odt_error_flg;

///////////////////////////////////////////////////////////////////////
// Check whether the ODT function has been disabled.
///////////////////////////////////////////////////////////////////////

reg                    odt_off;
wire                   otf_on;
wire                   bl8_cmd, bc4_cmd;

assign #1 mem_clk_dly = mem_clk;

initial begin 
    odt_error_flg = 0;
end

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
       odt_off <= 1'b0;
    end
    else 
       if (mem_lmr_cmd && (ddr_ba[1:0] == 2'b01)) begin // MR1
         odt_off <= ({ddr_ad[9],ddr_ad[6],ddr_ad[2]}== 3'b000);
         //odt_off <= 1'b1;    // sk   Disabled till ODT RTL is enabled
       end
end

assign otf_on  = (burst_len == 2'b01);
assign bc4_cmd = (burst_len == 2'b10);
assign bl8_cmd = (burst_len == 2'b00);


///////////////////////////////////////////////////////////////////////
// This logic detects the command presented at the memory interface.

assign mem_sref_cmd = ~(&ddr_cs_n) & ~ddr_ras_n & ~ddr_cas_n & ddr_we_n & ~ddr_cke;
assign mem_ref_cmd  = ~(&ddr_cs_n) & ddr_cke & ~ddr_ras_n & ~ddr_cas_n & ddr_we_n;
assign mem_aref_cmd = ~(&ddr_cs_n) & ddr_cke & ~ddr_ras_n & ~ddr_cas_n & ddr_we_n;
assign mem_pd_cmd   = ((~(&ddr_cs_n) & ddr_ras_n & ddr_cas_n & ddr_we_n & ~ddr_cke) | ((&ddr_cs_n) & ~ddr_cke)) & ~sr_active;
assign mem_lmr_cmd  = ~(&ddr_cs_n) & ~ddr_ras_n & ~ddr_cas_n & ~ddr_we_n;
assign mem_act_cmd  = ~(&ddr_cs_n) & ~ddr_ras_n & ddr_cas_n & ddr_we_n;
assign mem_pre_cmd  = ~(&ddr_cs_n) & ~ddr_ras_n & ddr_cas_n & ~ddr_we_n;
assign mem_nop_cmd  = (~(&ddr_cs_n) & ddr_ras_n & ddr_cas_n & ddr_we_n) | &ddr_cs_n;
assign mem_rd_cmd = ~(&ddr_cs_n) & ddr_ras_n & ~ddr_cas_n & ddr_we_n;
assign mem_wr_cmd = ~(&ddr_cs_n) & ddr_ras_n & ~ddr_cas_n & ~ddr_we_n;

assign pd_active = (mem_pd_cmd | pd_active) & ~ddr_cke;
assign sr_active = (mem_sref_cmd | sr_active) & ~ddr_cke;

always @(posedge mem_clk or negedge rst_n) begin
   if (!rst_n) begin
      pd_active_d <= 1'b0;
      sr_active_d <= 1'b0;
   end
   else begin
      pd_active_d <= pd_active;
      sr_active_d <= sr_active;
   end
end

assign mem_pd_ext_cmd   = ~pd_active & pd_active_d;
assign mem_sref_ext_cmd = ~sr_active & sr_active_d;

///////////////////////////////////////////////////////////////////////
// Part I : Minimum hold time check
///////////////////////////////////////////////////////////////////////

//reg                  bl8_cmd, bc4_cmd;
//reg  [2:0]           odt_min_held_tck;
reg  [CS_WIDTH-1:0] flop_ddr_odt;

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
	flop_ddr_odt <= 'b0;
    end
    else begin
	flop_ddr_odt <= ddr_odt;
    end
end



`ifdef CS_WIDTH_1
reg [2:0] odt_high_count;
wire      odt_high_count_start;
wire      odt_high_count_end;
wire      odt_min_held_met;

assign odt_high_count_start = (ddr_odt == 1'b1 && flop_ddr_odt == 1'b0);
assign odt_high_count_end   = (ddr_odt == 1'b0 && flop_ddr_odt == 1'b1);

always @ (posedge mem_clk or negedge rst_n) begin
  if (!rst_n) begin
    odt_high_count <= 3'h0;
  end
  else begin
    if (mem_wr_cmd) begin
      if (otf_on)
         odt_high_count <= {ddr_ad[12],~ddr_ad[12],1'b1};
      else
         odt_high_count <= {bl8_cmd,~bl8_cmd,1'b1};
    end
    else if (odt_high_count_start && (odt_high_count == 1'b0))
      odt_high_count <= 3'h3;
    else if (odt_high_count == 3'h0)
      odt_high_count <= odt_high_count;
    else
      odt_high_count <= odt_high_count - 1;
  end
end

assign odt_min_held_met = (odt_high_count == 0)? 1'b1:1'b0;

always @ (posedge mem_clk) begin
  if (odt_high_count_end  && odt_min_held_met == 1'b0 ) begin
      if (odt_off == 1'b0) begin
         $display ("ODT ERROR: ODT signals should be maintained high at time %0t for minimum held width requirement.\n",$time);
         odt_error_flg <= 1'b1;
      end
  end
end

`endif //CS_WIDTH_1

`ifdef CS_WIDTH_2
reg [2:0] odt_high_count_0;
reg [2:0] odt_high_count_1;

wire      odt_high_count_0_start;
wire      odt_high_count_1_start;

wire      odt_high_count_0_end;
wire      odt_high_count_1_end;

wire      odt_min_held_0_met;
wire      odt_min_held_1_met;

assign odt_high_count_0_start = (ddr_odt[0] == 1'b1 && flop_ddr_odt[0] == 1'b0);
assign odt_high_count_1_start = (ddr_odt[1] == 1'b1 && flop_ddr_odt[1] == 1'b0);

assign odt_high_count_0_end   = (ddr_odt[0] == 1'b0 && flop_ddr_odt[0] == 1'b1);
assign odt_high_count_1_end   = (ddr_odt[1] == 1'b0 && flop_ddr_odt[1] == 1'b1);

always @ (posedge mem_clk or negedge rst_n) begin
  if (!rst_n) begin
    odt_high_count_0 <= 3'h0;
  end
  else begin
    if (mem_wr_cmd) begin
      if (otf_on)
         odt_high_count_0 <= {ddr_ad[12],~ddr_ad[12],1'b1};
      else
         odt_high_count_0 <= {bl8_cmd,~bl8_cmd,1'b1};
    end
    else if (odt_high_count_0_start && (odt_high_count_0 == 1'b0)) begin
      odt_high_count_0 <= 3'h3;
    end
    else if (odt_high_count_0 == 3'h0) begin
      odt_high_count_0 <= odt_high_count_0;
    end
    else begin
      odt_high_count_0 <= odt_high_count_0 - 1;
    end
  end
end

always @ (posedge mem_clk or negedge rst_n) begin
  if (!rst_n) begin
    odt_high_count_1 <= 3'h0;
  end
  else begin
    if (mem_wr_cmd) begin
      if (otf_on)
         odt_high_count_1 <= {ddr_ad[12],~ddr_ad[12],1'b1};
      else
         odt_high_count_1 <= {bl8_cmd,~bl8_cmd,1'b1};
    end
    else if (odt_high_count_1_start && (odt_high_count_1 == 1'b0)) begin
      odt_high_count_1 <= 3'h3;
    end
    else if (odt_high_count_1 == 3'h0) begin
      odt_high_count_1 <= odt_high_count_1;
    end
    else begin
      odt_high_count_1 <= odt_high_count_1 - 1;
    end
  end
end

assign odt_min_held_met_0 = (odt_high_count_0 == 0)? 1'b1:1'b0;
assign odt_min_held_met_1 = (odt_high_count_1 == 0)? 1'b1:1'b0;

always @ (posedge mem_clk) begin
  if (odt_high_count_0_end  && odt_min_held_met_0 == 1'b0 ) begin
      if (odt_off == 1'b0) begin
        $display ("ODT ERROR: ODT signals bit 0 should be maintained high at time %0t for minimum held width requirement.\n",$time);
        odt_error_flg <= 1'b1;
      end
  end
  if (odt_high_count_1_end  && odt_min_held_met_1 == 1'b0 ) begin
      if (odt_off == 1'b0) begin
        $display ("ODT ERROR: ODT signals bit 1 should be maintained high at time %0t for minimum held width requirement.\n",$time);
        odt_error_flg <= 1'b1;
      end
  end
end

`endif //CS_WIDTH_2
        
///////////////////////////////////////////////////////////////////////
// Part II : Write & Read ODT check
///////////////////////////////////////////////////////////////////////

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
       mem_rd_cmd_d  <= 1'b0;
       mem_rd_cmd_2d <= 1'b0;
       mem_rd_cmd_3d <= 1'b0;
       mem_rd_cmd_4d <= 1'b0;
    end
    else begin
       mem_rd_cmd_d  <= mem_rd_cmd;
       mem_rd_cmd_2d <= mem_rd_cmd_d;
       mem_rd_cmd_3d <= mem_rd_cmd_2d;
       mem_rd_cmd_4d <= mem_rd_cmd_3d;
    end
end

wire [2:0] cl_minus_cwl;
assign cl_minus_cwl = cas_latency - cas_write_latency;

`ifdef CS_WIDTH_1

reg [3:0] wr_cmd_counter_0;
reg [3:0] rd_cmd_counter_0;

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
       wr_cmd_counter_0    <= 3'h0;
       rd_cmd_counter_0    <= 3'h0;
    end
    else begin
       // write ODT counter
       if (mem_wr_cmd && (ddr_cs_n == 1'b0))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : wr_cmd_counter_0 <= 3'h5;
             3'b010   : wr_cmd_counter_0 <= 3'h3;
             3'b011   : wr_cmd_counter_0 <= 3'h5;
             3'b10x   : wr_cmd_counter_0 <= 3'h3;
             default : wr_cmd_counter_0 <= 3'h3;
          endcase
       else if (wr_cmd_counter_0 == 3'h0)
          wr_cmd_counter_0 <= wr_cmd_counter_0;
       else
          wr_cmd_counter_0 <= wr_cmd_counter_0 - 1;

       // read ODT counter
       if (mem_rd_cmd && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b000))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 = 3'h6;
             3'b010   : rd_cmd_counter_0 = 3'h4;
             3'b011   : rd_cmd_counter_0 = 3'h6;
             3'b10x   : rd_cmd_counter_0 = 3'h4;
             default : rd_cmd_counter_0 = 3'h4;
          endcase
       else if (mem_rd_cmd && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b001))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_d && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b010))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_2d && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b011))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_3d && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b100))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_4d && (ddr_cs_n == 1'b0) && (cl_minus_cwl == 3'b101))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (rd_cmd_counter_0 == 3'h0)
          rd_cmd_counter_0 <= rd_cmd_counter_0;
       else if (cl_minus_cwl == 3'b000)
          rd_cmd_counter_0 = rd_cmd_counter_0 - 1;
       else
          rd_cmd_counter_0 <= rd_cmd_counter_0 - 1;

    end // else
end //always

// report error when ODT is wrong
always @ (posedge mem_clk_dly) begin
// write  
   if ((|wr_cmd_counter_0 || mem_wr_cmd) && (ddr_odt !== 1'b1))
       if (odt_off == 1'b0) begin
         $display ("ODT ERROR: ddr_odt should be asserted during write at time %0t\n",$time);
         odt_error_flg <= 1'b1;
       end
/*
// read
   if (|rd_cmd_counter_0 && (ddr_odt !== 1'b0))
       if (odt_off == 1'b0) begin
         $display ("ODT ERROR: ddr_odt should be deasserted during read at time %0t\n",$time);
         odt_error_flg <= 1'b1;
       end
*/
end

`endif //CS_WIDTH_1

`ifdef CS_WIDTH_2

reg [3:0] wr_cmd_counter_0;
reg [3:0] wr_cmd_counter_1;

reg [3:0] rd_cmd_counter_0;
reg [3:0] rd_cmd_counter_1;

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
       wr_cmd_counter_0    <= 3'h0;
       rd_cmd_counter_0    <= 3'h0;
    end
    else begin
       // write ODT counter
       if (mem_wr_cmd && (ddr_cs_n == 2'b10))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : wr_cmd_counter_0 <= 3'h5;
             3'b010   : wr_cmd_counter_0 <= 3'h3;
             3'b011   : wr_cmd_counter_0 <= 3'h5;
             3'b10x   : wr_cmd_counter_0 <= 3'h3;
             default : wr_cmd_counter_0 <= 3'h3;
          endcase
       else if (wr_cmd_counter_0 == 3'h0)
          wr_cmd_counter_0 <= wr_cmd_counter_0;
       else
          wr_cmd_counter_0 <= wr_cmd_counter_0 - 1;

       // read ODT counter
       if (mem_rd_cmd && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b000))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 = 3'h6;
             3'b010   : rd_cmd_counter_0 = 3'h4;
             3'b011   : rd_cmd_counter_0 = 3'h6;
             3'b10x   : rd_cmd_counter_0 = 3'h4;
             default : rd_cmd_counter_0 = 3'h4;
          endcase
       else if (mem_rd_cmd && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b001))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_d && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b010))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_2d && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b011))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_3d && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b100))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (mem_rd_cmd_4d && (ddr_cs_n == 2'b10) && (cl_minus_cwl == 3'b101))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_0 <= 3'h6;
             3'b010   : rd_cmd_counter_0 <= 3'h4;
             3'b011   : rd_cmd_counter_0 <= 3'h6;
             3'b10x   : rd_cmd_counter_0 <= 3'h4;
             default : rd_cmd_counter_0 <= 3'h4;
          endcase
       else if (rd_cmd_counter_0 == 3'h0)
          rd_cmd_counter_0 <= rd_cmd_counter_0;
       else if (cl_minus_cwl == 3'b000)
          rd_cmd_counter_0 = rd_cmd_counter_0 - 1;
       else
          rd_cmd_counter_0 <= rd_cmd_counter_0 - 1;

    end // else
end //always

always @ (posedge mem_clk or negedge rst_n) begin
    if (!rst_n) begin
       wr_cmd_counter_1    <= 3'h0;
       rd_cmd_counter_1    <= 3'h0;
end
    else begin
       // write ODT counter
       if (mem_wr_cmd && (ddr_cs_n == 2'b01))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : wr_cmd_counter_1 <= 3'h5;
             3'b010   : wr_cmd_counter_1 <= 3'h3;
             3'b011   : wr_cmd_counter_1 <= 3'h5;
             3'b10x   : wr_cmd_counter_1 <= 3'h3;
             default : wr_cmd_counter_1 <= 3'h3;
          endcase
       else if (wr_cmd_counter_1 == 3'h0)
          wr_cmd_counter_1 <= wr_cmd_counter_1;
       else
          wr_cmd_counter_1 <= wr_cmd_counter_1 - 1;

       // read ODT counter
       if (mem_rd_cmd && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b000))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 = 3'h6;
             3'b010   : rd_cmd_counter_1 = 3'h4;
             3'b011   : rd_cmd_counter_1 = 3'h6;
             3'b10x   : rd_cmd_counter_1 = 3'h4;
             default : rd_cmd_counter_1 = 3'h4;
          endcase
       else if (mem_rd_cmd && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b001))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 <= 3'h6;
             3'b010   : rd_cmd_counter_1 <= 3'h4;
             3'b011   : rd_cmd_counter_1 <= 3'h6;
             3'b10x   : rd_cmd_counter_1 <= 3'h4;
             default : rd_cmd_counter_1 <= 3'h4;
          endcase
       else if (mem_rd_cmd_d && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b010))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 <= 3'h6;
             3'b010   : rd_cmd_counter_1 <= 3'h4;
             3'b011   : rd_cmd_counter_1 <= 3'h6;
             3'b10x   : rd_cmd_counter_1 <= 3'h4;
             default : rd_cmd_counter_1 <= 3'h4;
          endcase
       else if (mem_rd_cmd_2d && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b011))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 <= 3'h6;
             3'b010   : rd_cmd_counter_1 <= 3'h4;
             3'b011   : rd_cmd_counter_1 <= 3'h6;
             3'b10x   : rd_cmd_counter_1 <= 3'h4;
             default : rd_cmd_counter_1 <= 3'h4;
          endcase
       else if (mem_rd_cmd_3d && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b100))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 <= 3'h6;
             3'b010   : rd_cmd_counter_1 <= 3'h4;
             3'b011   : rd_cmd_counter_1 <= 3'h6;
             3'b10x   : rd_cmd_counter_1 <= 3'h4;
             default : rd_cmd_counter_1 <= 3'h4;
          endcase
       else if (mem_rd_cmd_4d && (ddr_cs_n == 2'b01) && (cl_minus_cwl == 3'b101))
          casex ({burst_len, ddr_ad[12]})
             3'b00x   : rd_cmd_counter_1 <= 3'h6;
             3'b010   : rd_cmd_counter_1 <= 3'h4;
             3'b011   : rd_cmd_counter_1 <= 3'h6;
             3'b10x   : rd_cmd_counter_1 <= 3'h4;
             default : rd_cmd_counter_1 <= 3'h4;
          endcase
       else if (rd_cmd_counter_1 == 3'h0)
          rd_cmd_counter_1 <= rd_cmd_counter_1;
       else if (cl_minus_cwl == 3'b000)
          rd_cmd_counter_1 = rd_cmd_counter_1 - 1;
       else
          rd_cmd_counter_1 <= rd_cmd_counter_1 - 1;

    end // else
end //always

// report error when ODT is wrong
always @ (posedge mem_clk_dly) begin
// write  
  `ifdef DUAL_RANK
   if ( |wr_cmd_counter_0 || (mem_wr_cmd && ~ddr_cs_n[0]) || 
        |wr_cmd_counter_1 || (mem_wr_cmd && ~ddr_cs_n[1]) )
        if (ddr_odt !== 2'b01)
            if (odt_off == 1'b0) begin
               $display ("ODT ERROR: ddr_odt should be 2'b01 during write at time %0t\n",$time);
               odt_error_flg <= 1'b1;
            end

// read
   if ((|rd_cmd_counter_0 || |rd_cmd_counter_1))
        if (ddr_odt !== 2'b00)
            if (odt_off == 1'b0) begin
               $display ("ODT ERROR: ddr_odt should be 2'b00 during read at time %0t\n",$time);
               odt_error_flg <= 1'b1;
            end
  `else
     // 2 DIMMs, single Rank
   if ( |wr_cmd_counter_0 || (mem_wr_cmd && ~ddr_cs_n[0]) || 
        |wr_cmd_counter_1 || (mem_wr_cmd && ~ddr_cs_n[1]) )
        if (ddr_odt !== 2'b11)
            if (odt_off == 1'b0) begin
              $display ("ODT ERROR: ddr_odt should be 2'b11 during write at time %0t\n",$time);
              odt_error_flg <= 1'b1;
            end
/*
// read
   if (|rd_cmd_counter_0)
        if (ddr_odt !== 2'b10)
            if (odt_off == 1'b0) begin
              $display ("ODT ERROR: ddr_odt should be 2'b10 during read at time %0t\n",$time);
              odt_error_flg <= 1'b1;
            end

   if (|rd_cmd_counter_1)
        if (ddr_odt !== 2'b01)
            if (odt_off == 1'b0) begin
              $display ("ODT ERROR: ddr_odt should be 2'b01 during read at time %0t\n",$time);
              odt_error_flg <= 1'b1;
            end
*/

  `endif // DUAL_RANK

end


`endif //CS_WIDTH_2

// Write 

///////////////////////////////////////////////////////////////////////
// Part III : Self Refresh ODT check
///////////////////////////////////////////////////////////////////////

wire [9:0] sref_period;

assign sref_period = (sref_period | mem_sref_cmd) & ~self_ref_done;

always @ (posedge mem_clk) begin
   if (sref_period & |ddr_odt)
       if (odt_off == 1'b0) begin
	        $display ("ODT ERROR: ddr_odt should be turned off during self refresh at time %0t\n",$time);
           odt_error_flg <= 1'b1;
       end
end
      

endmodule
