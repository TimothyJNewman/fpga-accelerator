`ifndef LSCC_cmd_gen
`define LSCC_cmd_gen

// ===========================================================================
// Verilog module generated by IPexpress
// Filename: cmd_gen.v  
// Copyright 2009 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

///////////////////////////////////////////////////////////////////////
// Supported commands
// read          (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// write         (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// reada         (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// writea        (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, otf)
// self_ref      (cmd_valid_lat)
// load_mr       (cmd_valid_lat, bl, bt, cl, op)
// load_emr      (cmd_valid_lat, dll_disable, drive_strength)
// pdown         (cmd_valid_lat)
// init          ()
// burst_term    ()
//////////////////////////////////////////////////////////////////////

//---------------- Task reset ------------------------------------
task reset;
begin
  // Assert reset
  $display ("\nINFO: Ignore initial wait period warnings during functional simulation\n");
  rst_n_i              = 0;
  pll_rst_n_i          = 0;
  #(100*c) mem_rst_n_i = 0;
  
  // De-assert reset after 200 clock cycles
  #(100*c) rst_n_i     = 1;
  pll_rst_n_i          = 1;
  #(20*c)  mem_rst_n_i  = 1;
    if (ENB_MEM_RST == 1) begin
     wait(em_ddr_reset_n_o);
  end
end
endtask

// BUS_POSEDGE (lmmi_request, lmmi_wr_rdn, lmmi_offset, lmmi_wdata)
task BUS_POSEDGE (input request, input wr_rdn,
		input [ADDR_WIDTH-1:0] offset, input [ldata-1:0] wdata);
begin
		@(posedge sclk_o); 
	// lmmi signals
	#1  lmmi_request_i = request; lmmi_wr_rdn_i = wr_rdn; lmmi_offset_i = offset; lmmi_wdata_i = wdata;
end
endtask // BUS_POSEDGE

task init_lmmi;
begin
$display ("\nINFO : Initialization procedure Entry. Ignore warnings until Write Leveling procedure Exit\n");
  // Assert init_start
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 4'b0001,InitStart}); // Assert init_start
  BUS_POSEDGE(0, 1, {ADDR_WIDTH{lo}}, {6'd0, 4'b0001,InitStart}); // Deassert lmmi_request
   wait (tb_top.int_o) @ (posedge sclk_o);
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 4'b0000,InitStart});
   // init_start   = 0;
 
$display ("\nINFO : Initialization procedure Exit.\n");
end
endtask

//---------------- Task init ------------------------------------
// This task provides a initialization request
task init;
begin
  $display ("\nINFO : Initialization procedure Entry. Ignore warnings until Write Leveling procedure Exit\n");
  // Assert init_start
   wait(clocking_good_o) @(posedge sclk_o);
   init_start_i  = 1;
   wait (init_done_o   ) @ (posedge sclk_o);
   init_start_i   = 0;
  $display ("\nINFO : Initialization procedure Exit.%t \n", $time);
end
endtask


task enableInt (input int_number);
reg [2:0] int2Enable;
begin
  int2Enable = 1 << int_number;
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 1'b0, int2Enable, IntEnable});
end
endtask 

task disableAllInt (input int_number);
reg [2:0] int2Enable;
begin
  int2Enable = 3'b000;
  
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 1'b0, int2Enable, IntEnable});
end
endtask 

task clearInt (input int_number);
reg [2:0] int2Enable;
begin
  int2Enable = 1 << int_number;
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 1'b0, int2Enable, IntStatus});
end
endtask 

task pdown_lmmi;

begin
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 4'b0101, CmdR});
  wait(lmmi_ready_o);
  BUS_POSEDGE(0, 0, {ADDR_WIDTH{lo}}, {6'd0, 4'b0101, CmdR});
end
endtask

task pdown_ext_lmmi;

begin
  BUS_POSEDGE(1, 1, {ADDR_WIDTH{lo}}, {6'd0, 4'b1011, CmdR});
  wait(lmmi_ready_o);
  BUS_POSEDGE(0, 0, {ADDR_WIDTH{lo}}, {6'd0, 4'b0101, CmdR});
end
endtask


task m_write (
  input  [ADDR_WIDTH - 1: 0] addr,
  input  [2: 0] reg_addr,
  input  [ldata - 4: 0] data
);
  reg           done;
  begin
    //@(posedge sclk_o);
    lmmi_request_i <= hi;
    lmmi_wr_rdn_i <= hi;
	lmmi_wdata_i <= {data, CmdR};
	// {cmd_burst_cnt, ofly_burst_len_i, 4'b0010, CmdR}); // WRITE command
    // lmmi_wdata <= data;
    lmmi_offset_i <= addr;

    done = 0;
    while(!done) begin
      @(posedge sclk_o);
        done = lmmi_ready_o;
    end
    lmmi_request_i <= lo;
    lmmi_wr_rdn_i <= lo;
  end
endtask // m_write


task pdown; 
input  cmd_valid_lat;   //0:de-assert comand valid, 
                        //1:keep cmd_valid_i asserted
begin

   //wait (cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_i         = 4'b0101;
   cmd_valid_i   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);

   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
   end
*/
end
endtask

task pdown_ext; 
input  cmd_valid_lat;   //0:de-assert comand valid, 
                        //1:keep cmd_valid_i asserted
begin

   @(posedge sclk_o);
   #1;
   cmd_i         = 4'b1011;
   cmd_valid_i   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);

   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
   end
*/
end
endtask

task load_mr0;

input        cmd_valid_lat;   //0:de-assert comand valid,
                              //1:keep cmd_valid_i asserted
input[3:0]   bl;
input        bt;
input[3:0]   cl;
input[3:0]   wr_rec;

reg  [1:0]   bl_bits;
reg  [3:0]   cl_bits;
reg  [2:0]   wr_bits;
begin
   @(posedge sclk_o);
   #1;
   cmd_i         = 4'b0110;
   //check_bl_cl_wr (bl, cl, wr_rec, bl_bits, cl_bits, wr_bits);
   check_bl_cl_wr (bl, cl, TWR*2, bl_bits, cl_bits, wr_bits);
   addr_i[1:0]   = bl_bits;
   addr_i[2]     = cl_bits[0];
   addr_i[3]     = bt;
   addr_i[6:4]   = cl_bits[3:1];
   addr_i[7]     = 0;  //test mode set to 0
   addr_i[8]     = 0;  //dll reset set to No
   addr_i[11:9]  = wr_bits;
   addr_i[12]    = 0;  //Slow exit for Precharge_May01 Powerdown(DLL off)
   addr_i[18:13] = 2'b00; //mode register 0;
   cmd_valid_i   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
   end

/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);

   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
   end
*/
end
endtask

//---------------- Task read  -----------------------------------------
// read          (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr)
// This task issues the read command.
task read ;
input   cmd_valid_lat;   //0:de-assert comand valid,
		                   //1:keep cmd_valid_i asserted
input   burst_count;
input   row_addr;
input   bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge sclk_o);
   #1;
   cmd_i         = 4'b0001;
   ff_burst_count   = burst_count;
   addr_i[COL_WIDTH-1:0]                           = col_addr;
`ifndef DUAL_RANK
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]           = bank_addr;
`else
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]           = {cs_addr,bank_addr[2:0]};
`endif
   addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH]     = row_addr;
   ofly_burst_len_i = otf;

   `ifndef NO_INFO
   $display ("%t: TB: INFO: Read from Bank No.%5d, Row Addr :%5d, Col Addr: %5d", 
	     $time, bank_addr, row_addr, col_addr); 
   `endif

`ifdef CMD_VALID_TYPE1
//1st cmd_rdy_o: skip and assert cmd_valid_i
   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b1;
   end

//2nd cmd_rdy_o: Deassert cmd_valid_i
//             If opted, deassert all user side signals
   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
      `ifdef CLOSE_USR_SIG
        ff_burst_count   = 0;
        addr_i[COL_WIDTH-1:0]                      = 0;
        addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]      = 0;
        addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH] = 0;
        ofly_burst_len_i = 1;
      `endif

   end

//3rd cmd_rdy_o: skip
   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
   end

`else

   cmd_valid_i   = 1'b1;
   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
       cmd_i       = 'd0;   
      `ifdef CLOSE_USR_SIG
        ff_burst_count   = 0;
        addr_i[COL_WIDTH-1:0]                      = 0;
        addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]      = 0;
        addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH] = 0;
        ofly_burst_len_i = 1;
      `endif

   end

`endif

/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);
   
   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
       end
*/
end
endtask
//---------------- Task write  ----------------------------------------
task write;
input   cmd_valid_lat;   //0:de-assert comand valid,
                         //1:keep cmd_valid_i asserted
input   burst_count;
input   row_addr;
input [2:0] bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge sclk_o);
   #1;
   cmd_i         = 4'b0010;
   ff_burst_count   = burst_count;
   addr_i[COL_WIDTH-1:0]                         = col_addr;
`ifndef DUAL_RANK
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]           = bank_addr;
`else
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]           = {cs_addr,bank_addr[2:0]};
`endif

   addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH]     = row_addr;
   ofly_burst_len_i = otf;

   `ifndef NO_INFO
   $display ("%t: TB: INFO: Write to Bank No.%5d, Row Addr :%5d, Col Addr: %5d", 
	     $time, bank_addr, row_addr, col_addr); 
   `endif
   
`ifdef CMD_VALID_TYPE1
   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b1;
   end

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
      `ifdef CLOSE_USR_SIG
//        ff_burst_count   = 0;
        addr_i[COL_WIDTH-1:0]                      = 0;
        addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]      = 0;
        addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH] = 0;
        ofly_burst_len_i = 0;
      `endif

   end


   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
   end
   
`else

   cmd_valid_i   = 1'b1;

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
       cmd_i       = 'd0;   
      `ifdef CLOSE_USR_SIG
//        ff_burst_count   = 0;
        addr_i[COL_WIDTH-1:0]                      = 0;
        addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]      = 0;
        addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH] = 0;
        ofly_burst_len_i = 0;
      `endif

   end
`endif

/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);
   
   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
       end
*/
end
endtask

//---------------- Task writea  ----------------------------------------
task writea;
input   cmd_valid_lat;  //0:de-assert comand valid,
                        //1:keep cmd_valid_i asserted
input   burst_count;
input   row_addr;
input [2:0]  bank_addr;
input   col_addr;
input   otf;

integer burst_count;
integer row_addr;
integer bank_addr;
integer col_addr;

begin
   @(posedge sclk_o);
   #1;
   cmd_i = 4'b0100;
   ff_burst_count   = burst_count;
   addr_i[COL_WIDTH-1:0]                                       = col_addr;
`ifndef DUAL_RANK
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]                       = bank_addr;
`else
   addr_i[BSIZE+COL_WIDTH-1:COL_WIDTH]                       = {cs_addr,bank_addr[2:0]};
`endif
   addr_i[ROW_WIDTH+BSIZE+COL_WIDTH-1:BSIZE+COL_WIDTH]     = row_addr;
   ofly_burst_len_i = otf;
   cmd_valid_i   = 1'b1;
   `ifndef NO_INFO
   $display ("%t: TB: INFO: Writea to Bank No.%5d, Row Addr :%5d, Col Addr: %5d",
	     $time, bank_addr, row_addr, col_addr); 
   `endif

   if (!cmd_valid_lat) begin
       wait (cmd_rdy_o);
       @(posedge sclk_o);
       #1;
       cmd_valid_i = 1'b0;
       //write_data = 64'h0123_4567_89ab_cdef;
   end


/*
   // Stretch the command if the cmd_rdy_o was sampled asserted.
   // This will prevent the cmd_valid_i being de-asserted too soon.
   @(negedge cmd_rdy_o);
   @(posedge sclk_o);
   #1;
   cmd_valid_i   = 1'b1;
   @(posedge sclk_o);
   #1;
   @(negedge cmd_rdy_o);
   
   if (!cmd_valid_lat) begin
       @(negedge sclk_o);
       cmd_valid_i = 1'b0;
       end
*/
end
endtask
//---------------- Task check_bl_cl ---------------------------------
task check_bl_cl_wr;
input  [3:0] bl_in;
input  [3:0] cl_in;
input  [3:0] wr_in;

output [1:0] bl_out;
output [3:0] cl_out;
output [2:0] wr_out;

reg    [1:0] bl_out;
reg    [3:0] cl_out;
reg    [2:0] wr_out;
begin
   if((bl_in !== 4) && (bl_in !== 8) && (bl_in !== 0)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal Burst Length value %b\n",$time,bl_in); 
      $display ("cmd_gen ERROR: Allowed values: 4, 8, 0(on-the-fly) \n", 4, 8, 0);
      $display ("cmd_gen ERROR: Burst Length set to 8\n");
      bl_out = 2'b00; //bl set to 8
   end
   else begin
      case (bl_in)
         4 : bl_out = 2'b10;  // bc 4
         8 : bl_out = 2'b00;  // bl 8
         0 : bl_out = 2'b01;  // on-the-fly
      endcase
   end

   if((cl_in < 5) || (cl_in > 11)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal CAS Latency %b\n",$time,cl_in); 
      $display ("cmd_gen ERROR: Allowed values: 5,6,7,8,9,10,11(only for DDR3-1600) \n");
      $display ("cmd_gen ERROR: CAS Latency set to 6 \n");
   cl_out = 4'b0100; //cl set to 6
   end
   else begin
      case (cl_in)
         5  : cl_out = 4'b0010;
         6  : cl_out = 4'b0100;
         7  : cl_out = 4'b0110;
         8  : cl_out = 4'b1000;
         9  : cl_out = 4'b1010;
         10 : cl_out = 4'b1100;
         11 : cl_out = 4'b1110;
      endcase
   end

   if((wr_in < 5) || (wr_in > 12) || (wr_in == 9) || (wr_in == 11)) begin
      $display ("cmd_gen ERROR: at time %0t, Illegal Write recovery cycles %b\n",$time,wr_in); 
      $display ("cmd_gen ERROR: Allowed values: 5,6,7,8,9,10,11(only for DDR3-1600) \n");
      $display ("cmd_gen ERROR: CAS Latency set to 6 \n");
   wr_out = 3'b010; //wr set to 6
   end
   else begin
      case (wr_in)
         5  : wr_out = 3'b001;
         6  : wr_out = 3'b010;
         7  : wr_out = 3'b011;
         8  : wr_out = 3'b100;
         10 : wr_out = 3'b101;
         12 : wr_out = 3'b110;
      endcase
   end
end
endtask

//---------------- Task generate_data --------------------------------
task generate_data;
output [`DSIZE+(`DSIZE/8)-1:0] data_out ;
reg    [`DSIZE+(`DSIZE/8)-1:0] data_out ;
reg    [`DSIZE-1:0]            int_data_out ;
reg    [7:0]                   data8   [35:0];
reg    [`USER_DM-1:0]          dm_bits;
reg    [71:0]                  int_dm_bits;
integer                        i,j;
integer                        seed;
integer                        data8_cnt;

begin

`ifdef DATA_SIZE_32
    data8_cnt  = 16;
`endif

`ifdef DATA_SIZE_24
    data8_cnt  = 12;
`endif

`ifdef DATA_SIZE_16
    data8_cnt  = 8;
`endif

`ifdef DATA_SIZE_8
    data8_cnt  = 4;
`endif

   dm_bits = 'd0;

   //for (i=0; i<18; i=i+1) begin
   for (i=0; i<36; i=i+1) begin
      seed = seed+1;
      data8[i] = $random(seed);
   end
   
   int_dm_bits = dm_toggle ? {data8[8], data8[7], data8[6], data8[5], data8[4], data8[3], data8[2], data8[1], data8[0]}
                             : 72'h0;

`ifdef DATA_SIZE_32
   if (`GEAR == 2) begin
      int_data_out = {`GEAR_BY2{data8[15], data8[14], data8[13], data8[12],
				data8[11], data8[10], data8[9], data8[8],
				data8[7], data8[6], data8[5], data8[4],
				data8[3], data8[2], data8[1], data8[0]}};
      dm_bits = {`GEAR_BY2{int_dm_bits[15:0]}};
   end
   else if (`GEAR == 4) begin
      int_data_out = {data8[31], data8[30], data8[29], data8[28],
		      data8[27], data8[26], data8[25], data8[24],
		      data8[23], data8[22], data8[21], data8[20],
		      data8[19], data8[18], data8[17], data8[16],
		      data8[15], data8[14], data8[13], data8[12],
		      data8[11], data8[10], data8[9], data8[8],
		      data8[7], data8[6], data8[5], data8[4],
		      data8[3], data8[2], data8[1], data8[0]};
      dm_bits = int_dm_bits[31:0];
   end
`endif

`ifdef DATA_SIZE_24
   if (`GEAR == 2) begin
      int_data_out = {`GEAR_BY2{data8[11], data8[10], data8[9], data8[8],
				data8[7], data8[6], data8[5], data8[4],
				data8[3], data8[2], data8[1], data8[0]}};
      dm_bits = {`GEAR_BY2{int_dm_bits[11:0]}};
   end
   else if (`GEAR == 4) begin
      
      int_data_out = {data8[23], data8[22], data8[21], data8[20],
		      data8[19], data8[18], data8[17], data8[16],
		      data8[15], data8[14], data8[13], data8[12],
		      data8[11], data8[10], data8[9], data8[8],
		      data8[7], data8[6], data8[5], data8[4],
		      data8[3], data8[2], data8[1], data8[0]};
       dm_bits = int_dm_bits[23:0];
   end
`endif

`ifdef DATA_SIZE_16
   if (`GEAR == 2) begin
      int_data_out = {`GEAR_BY2{data8[7], data8[6], data8[5], data8[4],
				data8[3], data8[2], data8[1], data8[0]}};
      dm_bits = {`GEAR_BY2{int_dm_bits[7:0]}};
   end
   else if (`GEAR == 4) begin
      
      int_data_out = {data8[15], data8[14], data8[13], data8[12],
		      data8[11], data8[10], data8[9], data8[8],
		      data8[7], data8[6], data8[5], data8[4],
        	      data8[3], data8[2], data8[1], data8[0]}; 
      dm_bits = int_dm_bits[15:0];  
   end
`endif

`ifdef DATA_SIZE_8
   if (`GEAR == 2) begin
      int_data_out = {`GEAR_BY2{data8[3], data8[2], data8[1], data8[0]}};
      dm_bits = {`GEAR_BY2{int_dm_bits[3:0]}};
   end
   else if (`GEAR == 4) begin
      int_data_out = {data8[7], data8[6], data8[5], data8[4],
        		  data8[3], data8[2], data8[1], data8[0]};
      dm_bits = {int_dm_bits[7:0]};
   end
`endif

   data_out = {dm_bits, int_data_out};
end
endtask

//------------ Sending data for write/writea tasks --------------------
reg datain_valid_d;
reg datain_valid_2d;
reg datain_valid_3d;

always@ (posedge sclk_o) begin
    if(rst_n_i == 0) begin
      datain_valid_d  <= 1'b0;
    end 
    else begin 
       datain_valid_d  <= data_rdy;
       datain_valid_2d  <= datain_valid_d;
       if (WRRQDDELAY == 2'b01) begin
           if(data_rdy) begin
              generate_data({data_mask_i,write_data_i});
           end 
           else if (datain_valid_d) begin
               write_data_i = 0;
               data_mask_i  = 0;
           end
       end 
       else if (WRRQDDELAY == 2'b10) begin
           if(datain_valid_d) begin
              generate_data({data_mask_i,write_data_i});
           end 
           else if (datain_valid_2d) begin
               write_data_i = 0;
               data_mask_i  = 0;
           end
       end
    end
end

always @ (data_mask_i or dm_toggle) begin
    if (dm_toggle) begin
        dmsel = #1 data_mask_i;
    end
    else begin
        dmsel = 16'b0;
    end
end

`endif
